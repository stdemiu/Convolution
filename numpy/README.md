# Применение свёрточного фильтра к изображению кота с помощью NumPy

```python
import numpy as np
import matplotlib.pyplot as plt
from PIL import Image
```

### Используемые библиотеки
1. NumPy: Для эффективных математических операций, особенно матричных, необходимых для выполнения свёртки.
2. Matplotlib: Для отображения оригинального и обработанного изображения.
3. PIL (Python Imaging Library): Для загрузки и преобразования изображения в градации серого.

## Функция свёртки conv2d
Функция свёртки (конволюции), как conv2d, используется для выделения различных признаков на изображении — таких как края, текстуры, или другие важные детали. Свертка часто применяется в обработке изображений и машинном обучении, особенно в сверточных нейронных сетях (CNN), где она помогает обнаруживать паттерны и структурные элементы, такие как линии, формы и текстуры.

Функция conv2d предназначена для выполнения двухмерной свёртки, которая применяется к изображению с помощью определённого ядра (фильтра). Эта функция "проходит" по изображению, применяя фильтр к каждой области и вычисляя новую матрицу значений, которые отражают те особенности, которые выделяет ядро.

Свертка — это математическая операция, которая применяется к двум функциям (в данном случае, к двум матрицам — изображению и ядру свёртки). В двухмерной свертке мы "проходим" по всему изображению, умножая значения пикселей изображения на значения фильтра (или ядра) и складывая результаты. Это позволяет выделять определенные визуальные признаки.

```python
def conv2d(image, kernel):
    img_height, img_width = image.shape
    kernel_size = kernel.shape[0]
```

### Параметры
- image: Изображение в градациях серого, представленное как 2D массив NumPy.
- kernel: Ядро свёртки — небольшой матричный фильтр, который используется для обработки изображения. В этом примере используется фильтр 3x3 для детектирования краёв.

### Процесс
- img_height и img_width: Определяют высоту и ширину изображения.
- kernel_size: Определяет размер ядра. Мы предполагаем, что ядро квадратное, поэтому используем kernel.shape[0].


## Вычисление размеров выходного изображения

Когда выполняется свёртка изображения с ядром, размер выходного изображения уменьшается. Это происходит потому, что ядро не может полностью покрыть края изображения без выхода за границы.
Мы уменьшаем размер изображения на величину ядра - 1, так как свёртка проводится только на центральной части изображения, чтобы избежать выхода за границы.

Допустим, у нас есть изображение размером 5x5 и ядро размером 3x3. Если мы начнем свёртку с верхнего левого угла, то, чтобы получить значение свёртки, ядро должно полностью помещаться на изображении. Однако, по мере приближения к границам, ядро начинает "выходить за пределы" изображения. Чтобы избежать этого, свёртка выполняется только на центральной части изображения, где ядро полностью помещается.


```python
    output_height = img_height - kernel_size + 1
    output_width = img_width - kernel_size + 1
    output = np.zeros((output_height, output_width))
```

- output_height и output_width: Это размеры выходного изображения после применения свёртки.
- output: Создаём пустую матрицу (2D массив) размером output_height x output_width для хранения результатов.

Чтобы полностью покрывать центральные части изображения, ядро перемещается только внутри диапазона, который позволяет ему полностью "лежать" на изображении. При этом смещаемся на 1 пиксель вправо или вниз в каждом шаге.

Для матрицы 5x5 и ядра 3x3:

- Начальное положение (левый верхний угол): покрывает пиксели от [0,0] до [2,2].
- Следующее положение (сдвиг вправо): покрывает пиксели от [0,1] до [2,3].
Размер выходного изображения будет:

output_height=5−3+1=3

output_width=5−3+1=3

Таким образом, мы можем сдвинуться на 3 позиции вправо и на 3 позиции вниз, что создаёт результирующую матрицу 3x3.

## Выполнение свёртки
В этом цикле функция перемещает ядро по всему изображению и вычисляет значения для каждой позиции ядра.

```python
    for i in range(output_height):
        for j in range(output_width):
            output[i, j] = np.sum(image[i:i+kernel_size, j:j+kernel_size] * kernel)
```


- Циклы for: Перебираем каждый пиксель изображения, где ядро полностью помещается.
- image[i
+kernel_size, j
+kernel_size]: Извлекаем область изображения, которая соответствует размеру ядра.
- np.sum(... * kernel): Умножаем каждый элемент выделенной области на соответствующий элемент ядра, затем складываем все значения, чтобы получить одно итоговое значение.
- output[i, j]: Записываем результат в выходное изображение.


## Загрузка изображения и преобразование в градации серого
```python
img_path = '/content/drive/MyDrive/Univer/cat.jpeg'
img = Image.open(img_path).convert('L')
img = np.array(img)
```

- Image.open(img_path): Загружает изображение.
- convert('L'): Преобразует изображение в градации серого (модель 'L' означает "luminance" — яркость).
- np.array(img): Преобразует изображение в массив NumPy, что упрощает выполнение математических операций.


## Определение ядра свёртки (фильтра)
```python
kernel = np.array([[-1, -1, -1],
                   [-1,  8, -1],
                   [-1, -1, -1]])
```
                   
### Описание ядра
Ядро свёртки — это матрица (например, размером 3x3 или 5x5), которая определяет, какие элементы изображения будут выделены. Ядро обычно имеет меньший размер, чем само изображение, и смещается (сдвигается) по каждому пикселю изображения.
В этом ядре центральное значение 8 положительное, в то время как остальные значения отрицательные, что помогает выделить разницу между центральным пикселем и окружающими его пикселями. Этот фильтр выделяет края, так как края являются местами с резкими изменениями яркости.
Поскольку остальные значения равны −1, их сумма будет равна −8 (поскольку 8×−1=−8). Это как раз компенсирует центральное значение +8. В результате, если изображение не содержит резких изменений яркости (например, однотонная область), свёртка даст значение близкое к нулю, так как центральный пиксель компенсируется окружением.

Это ядро называется фильтром Лапласа, и оно используется для выделения краёв на изображении. Его основная цель — найти резкие изменения яркости, которые характерны для границ и контуров.
1. Центральный элемент равен 8, что придаёт вес центральному пикселю, отражая его яркость с высокой интенсивностью.
2. Остальные элементы равны −1, что означает, что значение каждого пикселя, окружающего центральный, будет вычитаться из него.

Этот фильтр используется для выделения краёв. Значение в центре ядра положительное и имеет большую величину, тогда как остальные значения отрицательные. Это усиливает контраст между центральным пикселем и его соседями, подчеркивая границы.

## Применение свёртки к изображению
```python
conv_result = conv2d(img, kernel)
```

Применяем функцию conv2d с заданным ядром для получения изображения с выделенными краями.


## Усиление контраста выходного изображения
Чтобы результат был более выразительным, нормализуем значения и усиливаем контраст:

```python
conv_result = (conv_result - np.min(conv_result)) / (np.max(conv_result) - np.min(conv_result)) * 255
conv_result = np.clip(conv_result * 2, 0, 255)
conv_result = conv_result.astype(np.uint8)
```

- Нормализация: Преобразуем значения в диапазон от 0 до 255.
- Усиление контраста: Умножаем значения на 2, чтобы сделать края более заметными.
- astype(np.uint8): Преобразуем значения в целые числа от 0 до 255 для совместимости с изображениями.


## Визуализация результата
```python
plt.figure(figsize=(10, 5))

plt.subplot(1, 2, 1)
plt.imshow(img, cmap='gray')
plt.title('Оригинальное изображение')

plt.subplot(1, 2, 2)
plt.imshow(conv_result, cmap='gray')
plt.title('Результат свертки с повышенным контрастом')

plt.show()
```

- plt.figure(figsize=(10, 5)): Устанавливаем размер области для двух изображений.
- plt.subplot(1, 2, 1): Первый subplot для оригинального изображения.
plt.imshow(img, cmap='gray'): Отображаем оригинальное изображение в градациях серого.
plt.subplot(1, 2, 2): Второй subplot для обработанного изображения.
plt.imshow(conv_result, cmap='gray'): Отображаем результат свёртки в градациях серого.
plt.show(): Показываем оба изображения на экране.
